#N canvas 418 28 646 737 12;
#X declare -lib aoo;
#X obj 379 223 declare -lib aoo;
#X msg 73 320 disconnect;
#X msg 343 320 disconnect;
#X text 38 25 [aoo_server] / [aoo_client]: objects for UDP hole punching
;
#X obj 64 488 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X obj 334 490 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X msg 62 578 add test bar 1;
#X msg 70 603 remove;
#X msg 346 604 uninvite;
#X msg 336 579 invite test foo 1;
#X msg 203 648 \; pd dsp \$1;
#X obj 203 627 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X msg 77 630 start;
#X msg 124 630 stop;
#N canvas 54 179 501 359 server 0;
#X obj 32 202 aoo_server 8002;
#X floatatom 32 227 5 0 0 0 - - -;
#N canvas 71 488 450 221 events 0;
#X obj 37 37 inlet;
#X obj 37 62 print aoo_server;
#X text 31 93 [user_join <user>(: a new user connected to the server
;
#X text 31 114 [user_leave <user>(: a user disconnected from the server
;
#X text 30 136 [group_join <group> <user>(: a user joined a group;
#X text 29 160 [group_leave <group> <user>(: a user left a group;
#X connect 0 0 1 0;
#X restore 134 227 pd events;
#X text 32 258 outlets:;
#X text 45 280 1) number of connected users;
#X text 45 300 2) events;
#X text 25 29 [aoo_server]: the UDP punch hole server;
#X text 28 56 creation arguments:;
#X text 45 78 1) port number;
#X text 28 107 Use this object to host an AOO server for your local
network or for the public internet.;
#X text 30 143 NOTE: If you want to connect clients over the public
internet \, your server machine must be publicly accessible and the
given port number must be known by all clients., f 58;
#X connect 0 0 1 0;
#X connect 0 1 2 0;
#X restore 129 224 pd server;
#N canvas 719 21 750 739 client 0;
#X text 24 17 [aoo_client]: the client;
#X text 26 127 creation arguments:;
#X text 50 147 1) port number, f 15;
#X obj 25 618 aoo_client;
#X text 25 171 messages:;
#X msg 35 298 disconnect;
#X text 385 590 outlets:;
#X msg 47 482 group_leave <group>;
#X text 25 48 Clients connect to the server and join a group to obtain
the public IP addresses of their peers \, which they don't know in
advance. This enables peers to send each other messages over the public
internet., f 96;
#X text 26 98 For more info \, see: https://en.wikipedia.org/wiki/UDP_hole_punching
, f 68;
#X msg 44 362 group_join <group> <password>;
#X text 264 292 Disconnect from the server.;
#X text 263 316 Both method are *asynchronous* and will output 1 on
success or 0 on failure.;
#N canvas 531 18 869 742 osc 0;
#X msg 37 64 disconnect;
#X obj 539 121 oscformat bazoo;
#X msg 539 95 1 2 3;
#X msg 528 65 disconnect;
#X msg 677 107 disconnect;
#X msg 45 92 broadcast <bytes>;
#X msg 53 121 send_group <group> <bytes>;
#X msg 75 212 send <bytes>;
#X msg 82 243 list <bytes>;
#X text 181 93 send an OSC message to all peers;
#X text 253 119 send to all peers in a given group, f 35;
#X text 298 151 send to a single peer;
#X msg 68 182 send_peer <IP> <port> <bytes>;
#X msg 106 362 target;
#X msg 100 331 target <group>;
#X msg 89 273 target <group> <user>;
#X msg 60 152 send_peer <group> <user> <bytes>;
#X msg 95 303 target <IP> <port>;
#X text 176 208 send an OSC message to the current target (more efficient
than the methods above), f 43;
#X text 180 244 "send" selector is optional;
#X text 251 274 target a single peer;
#X text 211 334 target a group;
#X text 161 362 broadcast (= default);
#X msg 112 394 offset <f>;
#X obj 48 689 print A;
#X text 144 639 The third outlet outputs the sender as;
#X msg 421 639 list <IP> <port> <delay>;
#X msg 551 174 target test2 C;
#X msg 557 200 target;
#X msg 562 251 offset \$1;
#X obj 562 228 nbx 5 14 -1e+037 1e+037 0 0 empty empty empty 0 -8 0
10 -262144 -1 -1 1 256;
#X msg 121 506 schedule \$1;
#X obj 121 485 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X text 218 483 1: automatically schedule OSC bundle elements according
to their timetags (= default)., f 47;
#X text 219 518 0: don't schedule \, instead output the required delay.
, f 54;
#X text 145 609 Incoming OSC messages are sent to the second outlet
as a list of bytes., f 71;
#X obj 48 661 oscparse;
#X obj 48 636 route list;
#X obj 570 332 oscparse;
#X obj 570 307 route list;
#X obj 719 371 oscparse;
#X obj 719 346 route list;
#X obj 719 399 print C;
#X obj 570 359 print B;
#X text 143 668 <delay> is the difference in ms between the OSC timetag
and the current system time. It is always 0 for immediate OSC messages.
Late messages (= timetag expired before arrival) have a negative delay.
, f 85;
#X obj 27 635 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X obj 519 306 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X obj 668 346 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X obj 27 608 aoo_client 9992;
#X obj 519 280 aoo_client 9993;
#X obj 668 320 aoo_client 9994;
#X text 198 390 Set the timetag offset in ms. This will schedule OSC
messages as bundles \, with a timetag based on the current NTP time
+ offset. "offset" is ignored for OSC bundles \, because they already
contain a timetag!, f 66;
#X msg 28 36 connect localhost 8002 A _ test2 _;
#X msg 122 568 discard_late \$1;
#X obj 122 546 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X text 246 547 Discard late bundles. This is only relevant for automatic
scheduling. With manual scheduling \, users can simply filter messages
with a negative delay., f 58;
#X msg 519 39 connect localhost 8002 B _ test2 _;
#X msg 546 147 target test2 A;
#X msg 669 67 connect localhost 8002 C _ test2 _, f 23;
#X obj 684 164 oscformat bazoo;
#X msg 684 139 1 2 3;
#X msg 702 244 target;
#X msg 707 292 offset \$1;
#X obj 707 269 nbx 5 14 -1e+037 1e+037 0 0 empty empty empty 0 -8 0
10 -262144 -1 -1 0 256;
#X msg 691 191 target test2 A;
#X msg 696 218 target test2 B;
#X msg 115 456 offset -1;
#X text 200 456 No offset (send as regular OSC message). This is the
default., f 61;
#X msg 621 225 -1;
#X msg 766 266 -1;
#X connect 0 0 48 0;
#X connect 1 0 49 0;
#X connect 2 0 1 0;
#X connect 3 0 49 0;
#X connect 4 0 50 0;
#X connect 5 0 48 0;
#X connect 6 0 48 0;
#X connect 7 0 48 0;
#X connect 8 0 48 0;
#X connect 12 0 48 0;
#X connect 13 0 48 0;
#X connect 14 0 48 0;
#X connect 15 0 48 0;
#X connect 16 0 48 0;
#X connect 17 0 48 0;
#X connect 23 0 48 0;
#X connect 27 0 49 0;
#X connect 28 0 49 0;
#X connect 29 0 49 0;
#X connect 30 0 29 0;
#X connect 31 0 48 0;
#X connect 32 0 31 0;
#X connect 36 0 24 0;
#X connect 37 0 36 0;
#X connect 37 1 24 0;
#X connect 38 0 43 0;
#X connect 39 0 38 0;
#X connect 39 1 43 0;
#X connect 40 0 42 0;
#X connect 41 0 40 0;
#X connect 41 1 42 0;
#X connect 48 0 45 0;
#X connect 48 1 37 0;
#X connect 48 2 24 0;
#X connect 49 0 46 0;
#X connect 49 1 39 0;
#X connect 49 2 43 0;
#X connect 50 0 47 0;
#X connect 50 1 41 0;
#X connect 50 2 42 0;
#X connect 52 0 48 0;
#X connect 53 0 48 0;
#X connect 54 0 53 0;
#X connect 56 0 49 0;
#X connect 57 0 49 0;
#X connect 58 0 50 0;
#X connect 59 0 50 0;
#X connect 60 0 59 0;
#X connect 61 0 50 0;
#X connect 62 0 50 0;
#X connect 63 0 62 0;
#X connect 64 0 50 0;
#X connect 65 0 50 0;
#X connect 66 0 48 0;
#X connect 68 0 29 0;
#X connect 69 0 62 0;
#X restore 261 589 pd osc messages;
#X text 396 615 1) connection status (1|0);
#X text 396 663 3) peer address (see "osc messages");
#X text 396 639 2) events/replies;
#N canvas 936 498 593 260 events/replies 0;
#X msg 32 73 group_join <group> <result>;
#X msg 33 101 group_leave <group> <result>;
#X text 247 95 <result> is 1 on success and 0 on failure, f 26;
#X msg 33 146 peer <group> <user> <id> <IP> <port>;
#X msg 32 183 peer_join <group> <user> <id> <IP> <port>;
#X msg 32 220 peer_leave <group> <user> <id> <IP> <port>;
#X text 244 71 reply to [group_join( resp. [group_leave(;
#X text 296 145 reply to [peer_list(;
#X text 344 220 a peer has left the group;
#X text 335 181 a new peer has joined the group;
#X msg 32 31 list <bytes...>;
#X text 153 31 OSC message received from peer;
#X restore 528 639 pd events/replies;
#X text 268 504 Both methods are asynchronous and will output a [group_join(
resp. [group_leave( message on success/failure (see "replies")., f
63;
#X text 268 418 You will get a [peer_join( message for every existing
peer in the group (see "events")., f 63;
#X msg 58 545 peer_list;
#X text 267 384 The group password is shared by all users. If you don't
care too much about security \, just use the group name itself., f
63;
#X text 269 455 NOTE: it's possible to join several groups in parallel!
, f 62;
#X text 60 589 Send OSC messages to peers:;
#X text 190 125 Each user on a given server has a unique ID., f 45
;
#X text 191 146 A peer is defined by its group name \, user name \,
user ID \, IP address and port number., f 67;
#X msg 33 245 connect <hostname> <port> <username> <password> <groupname>
<password>, f 37;
#X msg 25 197 connect <hostname> <port> <username> <password>, f 26
;
#X text 232 189 Connect to the server as a user. The password can be
chosen freely. Although it will be hashed \, better don't use the one
of your e-mail or banking account :-), f 61;
#X text 312 244 Connect to the server and immediately join a group.
;
#X text 314 264 See [join_group(.;
#X text 267 362 Join group. You must be logged in as a user.;
#X text 202 480 Leave a group.;
#X text 142 546 Get a list all a peers. This will output a series of
[peer( messages. See "events/replies"., f 70;
#X connect 5 0 3 0;
#X connect 7 0 3 0;
#X connect 10 0 3 0;
#X connect 20 0 3 0;
#X connect 27 0 3 0;
#X restore 208 224 pd client;
#X obj 91 401 oscformat bazoo;
#X msg 91 374 1 2 3;
#X msg 358 397 1 2 3;
#X obj 358 426 oscformat hooray;
#X text 40 95 A client on a given port first connects to a public AOO
server. Once it has joined a group \, it receives a list of all existing
peers in that group and gets notified whenever a new peer joins the
group., f 76;
#X text 41 55 These objects allow peers to easily communicate with
each other in a local network or over the public internet., f 75;
#X text 43 223 More info:;
#X text 41 193 You can always use the AOO server of the IEM: vrr.iem.at
7077, f 63;
#X obj 115 490 route list;
#X obj 115 514 oscparse;
#X obj 385 491 route list;
#X obj 385 517 oscparse;
#X obj 64 464 aoo_client 9990;
#X obj 334 464 aoo_client 9991;
#X obj 62 661 aoo_send~ 9990 1;
#X obj 336 660 aoo_receive~ 9991 1;
#X text 115 348 send a message to all peers;
#X text 45 258 <hostname> <port> <username> <password> <groupname>
<password>, f 64;
#X msg 65 292 connect localhost 8002 foo _ test _;
#X msg 334 292 connect localhost 8002 bar _ test _;
#X obj 91 349 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 358 348 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X text 403 344 send a message to a single peer (test|foo), f 32;
#X obj 358 368 t b b;
#X msg 409 397 target test foo;
#X obj 115 543 print FOO;
#X obj 385 546 print BAR;
#X obj 62 688 print FOO;
#X obj 466 687 print BAR;
#X text 41 151 A peer is referenced by its group and user name. All
AOO objects on the same port share the same peer list., f 77;
#X connect 1 0 28 0;
#X connect 2 0 29 0;
#X connect 6 0 30 0;
#X connect 7 0 30 0;
#X connect 8 0 31 0;
#X connect 9 0 31 0;
#X connect 11 0 10 0;
#X connect 12 0 30 0;
#X connect 13 0 30 0;
#X connect 16 0 28 0;
#X connect 17 0 16 0;
#X connect 18 0 19 0;
#X connect 19 0 29 0;
#X connect 24 0 25 0;
#X connect 24 1 41 0;
#X connect 25 0 41 0;
#X connect 26 0 27 0;
#X connect 26 1 42 0;
#X connect 27 0 42 0;
#X connect 28 0 4 0;
#X connect 28 1 24 0;
#X connect 28 2 41 0;
#X connect 29 0 5 0;
#X connect 29 1 26 0;
#X connect 29 2 42 0;
#X connect 30 0 43 0;
#X connect 31 1 44 0;
#X connect 34 0 28 0;
#X connect 35 0 29 0;
#X connect 36 0 17 0;
#X connect 37 0 39 0;
#X connect 39 0 18 0;
#X connect 39 1 40 0;
#X connect 40 0 29 0;
